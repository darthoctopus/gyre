! Module  : evol_model_m
! Purpose : stellar evolutionary model
!
! Copyright 2013-2022 Rich Townsend & The GYRE Team
!
! This file is part of GYRE. GYRE is free software: you can
! redistribute it and/or modify it under the terms of the GNU General
! Public License as published by the Free Software Foundation, version 3.
!
! GYRE is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'gyre.inc'

module evol_model_m

   ! Uses

   use forum_m, only: RD

   use constants_m
   use grid_m
   use interp_m
   use math_m
   use model_m
   use model_par_m
   use point_m
   use util_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Derived-type definitions

   type, extends(model_t) :: evol_model_t
      private
      type(grid_t)                 :: gr
      type(interp_rt), allocatable :: in(:,:)
      logical, allocatable         :: in_def(:)
      real(RD), public             :: M_star
      real(RD), public             :: R_star
      real(RD), public             :: L_star
      logical                      :: add_center
      logical                      :: repair_As
      logical                      :: repair_derivs
      integer                      :: s_i
      integer                      :: s_o
      character(:), allocatable    :: deriv_type
      logical                      :: committed
   contains
      private
      procedure, public :: define
      procedure, public :: commit
      procedure, public :: coeff
      procedure, public :: dcoeff
      procedure, public :: M_r
      procedure, public :: P
      procedure, public :: rho
      procedure, public :: T
      procedure, public :: is_defined
      procedure, public :: is_vacuum
      procedure, public :: Delta_p
      procedure, public :: Delta_g
      procedure, public :: grid
   end type evol_model_t

   ! Interfaces

   interface evol_model_t
      module procedure evol_model_t_
   end interface evol_model_t

   ! Access specifiers

   public :: evol_model_t

   ! Default access

   private

contains

   function evol_model_t_(x, M_star, R_star, L_star, ml_p) result(ml)

      real(RD), intent(in)          :: x(:)
      real(RD), intent(in)          :: M_star
      real(RD), intent(in)          :: R_star
      real(RD), intent(in)          :: L_star
      type(model_par_t), intent(in) :: ml_p
      type(evol_model_t)            :: ml

      ! Construct the evol_model_t

      ! Create the grid

      if (ml_p%add_center) then

         if (x(1) /= 0._RD) then

            ml%gr = grid_t([0._RD,x])
            ml%add_center = .TRUE.

            if (check_log_level('INFO')) then
               write(OUTPUT_UNIT, 100) 'Added central point'
100            format(3X,A)
            endif

         else

            ml%gr = grid_t(x)
            ml%add_center = .FALSE.

            if (check_log_level('INFO')) then
               write(OUTPUT_UNIT, 100) 'No need to add central point'
            endif

         endif

      else

         ml%gr = grid_t(x)
         ml%add_center = .FALSE.

      endif

      ! Allocate arrays

      ml%s_i = ml%gr%s_i()
      ml%s_o = ml%gr%s_o()

      allocate(ml%in(I_LAST,ml%s_i:ml%s_o))

      allocate(ml%in_def(I_LAST))

      ml%in_def = .FALSE.

      ! Other initializations

      ml%M_star = M_star
      ml%R_star = R_star
      ml%L_star = L_star

      ml%repair_As = ml_p%repair_As
      ml%repair_derivs = ml_p%repair_derivs

      ml%deriv_type = ml_p%deriv_type

      ml%committed = .FALSE.

      ! Finish

      return

   end function evol_model_t_

   !****

   subroutine define(this, i, coeff)

      class(evol_model_t), intent(inout) :: this
      integer, intent(in)                :: i
      real(RD), intent(in)               :: coeff(:)

      real(RD), allocatable :: coeff_(:)
      real(RD)              :: coeff_0
      integer               :: s
      integer               :: j_i
      integer               :: j_o

      @:ASSERT_DEBUG(.NOT. this%committed, 'Cannot define coefficient after committing model')

      @:ASSERT_DEBUG(i >= 1 .AND. i <= I_LAST, 'Invalid index')

      ! Define the i'th coefficient

      ! If necessary, add a central point

      if (this%add_center) then

         select case (i)
         case (I_U)

            coeff_0 = 3._RD

         case (I_AS)

            coeff_0 = 0._RD

         case default

            ! Interpolate coeff at x=0 using parabolic fitting

            associate (x_1 => this%gr%pt(2)%x, &
               x_2 => this%gr%pt(3)%x)
               coeff_0 = (x_2**2*coeff(1) - x_1**2*coeff(2))/(x_2**2 - x_1**2)
            end associate

         end select

         coeff_ = [coeff_0,coeff]

      else

         coeff_ = coeff

      endif

      @:CHECK_BOUNDS(SIZE(coeff_), this%gr%n)

      ! If necessary, repair data at segment boundaries

      select case (i)
      case (I_AS)
         if (this%repair_As) call repair_coeff_(this%gr, coeff_)
      end select

      ! Set up per-segment interpolants

      seg_loop : do s = this%s_i, this%s_o

         ! Set up the interpolant

         j_i = this%gr%j_s_i(s)
         j_o = this%gr%j_s_o(s)

         if (this%gr%pt(j_i)%x == 0._RD) then
            this%in(i,s) = interp_rt(this%gr%pt(j_i:j_o)%x, coeff_(j_i:j_o), this%deriv_type, df_dx_a=0._RD)
         else
            this%in(i,s) = interp_rt(this%gr%pt(j_i:j_o)%x, coeff_(j_i:j_o), this%deriv_type)
         endif

      end do seg_loop

      this%in_def(i) = .TRUE.

      ! Finish

      return

   end subroutine define

   !****

   subroutine repair_coeff_(gr, coeff)

      type(grid_t), intent(in) :: gr
      real(RD), intent(inout)  :: coeff(:)

      integer :: s_i
      integer :: s_o
      integer :: s
      integer :: j_i
      integer :: j_o

      ! Repair coefficient data at segment boundaries, via linear
      ! interpolation from the segment interior

      s_i = gr%s_i()
      s_o = gr%s_o()

      seg_loop : do s = s_i, s_o

         j_i = gr%j_s_i(s)
         j_o = gr%j_s_o(s)

         if (s > s_i .AND. j_i + 2 <= j_o) then
            coeff(j_i) = coeff(j_i+1) + (gr%pt(j_i)%x - gr%pt(j_i+1)%x)*(coeff(j_i+2) - coeff(j_i+1))/&
               (gr%pt(j_i+2)%x - gr%pt(j_i+1)%x)
         endif

         if (s < s_o .AND. j_o - 2 >= j_i) then
            coeff(j_o) = coeff(j_o-1) + (gr%pt(j_o)%x - gr%pt(j_o-1)%x)*(coeff(j_o-1) - coeff(j_o-2))/ &
               (gr%pt(j_o-1)%x - gr%pt(j_o-2)%x)
         endif

      end do seg_loop

      ! Finish

      return

   end subroutine repair_coeff_

   !****

   subroutine commit(this)

      class(evol_model_t), intent(inout) :: this

      integer               :: s
      integer               :: j_i
      integer               :: j_o
      real(RD), allocatable :: x(:)
      real(RD), allocatable :: V_2(:)
      real(RD), allocatable :: As(:)
      real(RD), allocatable :: U(:)
      real(RD), allocatable :: c_1(:)
      real(RD), allocatable :: Gamma_1(:)
      real(RD), allocatable :: dV_2_dx(:)
      real(RD), allocatable :: dc_1_dx(:)
      real(RD), allocatable :: dU_dx(:)

      ! Commit the model

      ! If necessary, repair derivatives of U and c_1

      if (this%repair_derivs) then

         seg_loop : do s = this%s_i, this%s_o

            j_i = this%gr%j_s_i(s)
            j_o = this%gr%j_s_o(s)

            ! Get coefficients

            x = this%in(I_U, s)%x()

            U = this%in(I_U, s)%f()
            c_1 = this%in(I_C_1, s)%f()
            As = this%in(I_AS, s)%f()
            V_2 = this%in(I_V_2, s)%f()
            Gamma_1 = this%in(I_GAMMA_1, S)%f()

            ! Evaluate new derivatives for V_2, U and c_1, following
            ! eqns. (20) and (21) of Takata (2006) plus the equation
            ! of hydrostatic equilibrium

            allocate(dV_2_dx(SIZE(x)))
            allocate(dU_dx(SIZE(x)))
            allocate(dc_1_dx(SIZE(x)))

            where (x /= 0._RD)
               dV_2_dx = V_2*(V_2*x**2 - V_2*x**2/Gamma_1 - As + U - 3._RD)/x
               dU_dx = U*(-V_2*x**2/Gamma_1 - As - U + 3._RD)/x
               dc_1_dx = c_1*(3 - U)/x
            elsewhere
               dV_2_dx = 0._RD
               dU_dx = 0._RD
               dc_1_dx = 0._RD
            end where

            this%in(I_V_2, s) = interp_rt(x, V_2, dV_2_dx)
            this%in(I_C_1, s) = interp_rt(x, c_1, dc_1_dx)
            this%in(I_U, s) = interp_rt(x, U, dU_dx)

            deallocate(dc_1_dx)
            deallocate(dU_dx)
            deallocate(dV_2_dx)

         end do seg_loop

      end if

      ! Update the committed flag

      this%committed = .TRUE.

      ! Finish

      return

   end subroutine commit

   !****

   function coeff(this, i, pt)

      class(evol_model_t), intent(in) :: this
      integer, intent(in)             :: i
      type(point_t), intent(in)       :: pt
      real(RD)                        :: coeff

      @:ASSERT_DEBUG(this%committed, 'Cannot evaluate coefficient before committing model')

      @:ASSERT_DEBUG(i >= 1 .AND. i <= I_LAST, 'Invalid index')
      @:ASSERT_DEBUG(this%is_defined(i), 'Undefined coefficient')

      @:ASSERT_DEBUG(pt%s >= this%s_i .AND. pt%s <= this%s_o, 'Invalid segment')

      ! Evaluate the i'th coefficient

      associate (s => pt%s, x => pt%x)
         coeff = this%in(i,s)%f(x)
      end associate

      ! Finish

      return

   end function coeff

   !****

   function dcoeff(this, i, pt)

      class(evol_model_t), intent(in) :: this
      integer, intent(in)             :: i
      type(point_t), intent(in)       :: pt
      real(RD)                        :: dcoeff

      @:ASSERT_DEBUG(this%committed, 'Cannot evaluate coefficient before committing model')

      @:ASSERT_DEBUG(i >= 1 .AND. i <= I_LAST, 'Invalid index')
      @:ASSERT_DEBUG(this%is_defined(i), 'Undefined coefficient')

      @:ASSERT_DEBUG(pt%s >= this%s_i .AND. pt%s <= this%s_o, 'Invalid segment')

      ! Evaluate the logarithmic derivative of the i'th coefficient

      associate (s => pt%s, x => pt%x)
         if (x == 0._RD) then
            dcoeff = 0._RD
         else
            dcoeff = x*this%in(i,s)%df_dx(x)/this%in(i,s)%f(x)
         end if
      end associate

      ! Finish

      return

   end function dcoeff

   !****

   function M_r(this, pt)

      class(evol_model_t), intent(in) :: this
      type(point_t), intent(in)       :: pt
      real(RD)                        :: M_r

      ! Evaluate the fractional mass coordinate

      M_r = this%M_star*(pt%x**3/this%coeff(I_C_1, pt))

      ! Finish

      return

   end function M_r

   !****

   function P(this, pt)

      class(evol_model_t), intent(in) :: this
      type(point_t), intent(in)       :: pt
      real(RD)                        :: P

      ! Evaluate the total pressure

      P = (G_GRAVITY*this%M_star**2/(4._RD*PI*this%R_star**4))* &
         (this%coeff(I_U, pt)/(this%coeff(I_C_1, pt)**2*this%coeff(I_V_2, pt)))

      ! Finish

      return

   end function P

   !****

   function rho(this, pt)

      class(evol_model_t), intent(in) :: this
      type(point_t), intent(in)       :: pt
      real(RD)                        :: rho

      ! Evaluate the density

      rho = (this%M_star/(4._RD*PI*this%R_star**3))*(this%coeff(I_U, pt)/this%coeff(I_C_1, pt))

      ! Finish

      return

   end function rho

   !****

   function T(this, pt)

      class(evol_model_t), intent(in) :: this
      type(point_t), intent(in)       :: pt
      real(RD)                        :: T

      ! Evaluate the temperature

      T = (3._RD*this%coeff(I_BETA_RAD, pt)*this%P(pt)/A_RADIATION)**0.25_RD

      ! Finish

      return

   end function T

   !****

   function is_defined(this, i)

      class(evol_model_t), intent(in) :: this
      integer, intent(in)             :: i
      logical                         :: is_defined

      @:ASSERT_DEBUG(i >= 1 .AND. i <= I_LAST, 'invalid index')

      ! Return the definition status of the i'th coefficient

      is_defined = this%in_def(i)

      ! Finish

      return

   end function is_defined

   !****

   function is_vacuum(this, pt)

      class(evol_model_t), intent(in) :: this
      type(point_t), intent(in)       :: pt
      logical                         :: is_vacuum

      @:ASSERT_DEBUG(pt%s >= this%s_i .AND. pt%s <= this%s_o, 'invalid segment')

      ! Return whether the point is a vacuum

      is_vacuum = this%coeff(I_U,pt) == 0._RD

      ! Finish

      return

   end function is_vacuum

   !****

   function Delta_p(this, x_i, x_o)

      class(evol_model_t), intent(in) :: this
      real(RD), intent(in)            :: x_i
      real(RD), intent(in)            :: x_o
      real(RD)                        :: Delta_p

      type(grid_t)  :: gr
      real(RD)      :: I
      integer       :: s
      type(point_t) :: pt
      integer       :: j_i
      integer       :: j_o
      integer       :: j
      real(RD)      :: V_2
      real(RD)      :: c_1
      real(RD)      :: Gamma_1

      ! Evaluate the dimensionless g-mode inverse period separation,
      ! using a midpoint quadrature rule since the integrand can
      ! diverge at the surface

      ! First, create the nested grid

      gr = grid_t(this%gr, x_i, x_o)

      ! Now evaluate the integrand segment by segment

      I = 0._RD

      seg_loop : do s = gr%s_i(), gr%s_o()

         pt%s = s

         j_i = gr%j_s_i(s)
         j_o = gr%j_s_o(s)

         cell_loop : do j = j_i, j_o-1

            pt%x = 0.5*(gr%pt(j)%x + gr%pt(j+1)%x)

            V_2 = this%coeff(I_V_2, pt)
            c_1 = this%coeff(I_C_1, pt)
            Gamma_1 = this%coeff(I_GAMMA_1, pt)

            I = I + sqrt(c_1*V_2/Gamma_1)*(gr%pt(j+1)%x - gr%pt(j)%x)

         end do cell_loop

      end do seg_loop

      Delta_p = 0.5_RD/I

      ! Finish

      return

   end function Delta_p

   !****

   function Delta_g(this, x_i, x_o, lambda)

      class(evol_model_t), intent(in) :: this
      real(RD), intent(in)            :: x_i
      real(RD), intent(in)            :: x_o
      real(RD), intent(in)            :: lambda
      real(RD)                        :: Delta_g

      type(grid_t)  :: gr
      real(RD)      :: I
      integer       :: s
      type(point_t) :: pt
      integer       :: j_i
      integer       :: j_o
      integer       :: j
      real(RD)      :: As
      real(RD)      :: c_1

      ! Evaluate the dimensionless g-mode inverse period separation,
      ! using a midpoint quadrature rule since the integrand can diverge
      ! at the boundaries

      ! First, create the nested grid

      gr = grid_t(this%gr, x_i, x_o)

      ! Now evaluate the integrand segment by segment

      I = 0._RD

      seg_loop : do s = gr%s_i(), gr%s_o()

         pt%s = s

         j_i = gr%j_s_i(s)
         j_o = gr%j_s_o(s)

         cell_loop : do j = j_i, j_o-1

            pt%x = 0.5*(gr%pt(j)%x + gr%pt(j+1)%x)

            As = this%coeff(I_AS, pt)
            c_1 = this%coeff(I_C_1, pt)

            I = I + (sqrt(MAX(As/c_1, 0._RD))/pt%x)*(gr%pt(j+1)%x - gr%pt(j)%x)

         end do cell_loop

      end do seg_loop

      Delta_g = sqrt(lambda)/(2._RD*PI**2)*I

      ! Finish

      return

   end function Delta_g

   !****

   function grid(this)

      class(evol_model_t), intent(in) :: this
      type(grid_t)                    :: grid

      ! Return the model grid

      grid = this%gr

      ! Finish

      return

   end function grid

end module evol_model_m
